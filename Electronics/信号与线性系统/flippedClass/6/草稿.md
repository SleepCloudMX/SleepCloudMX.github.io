<h1 align="center">第六次翻转课堂草稿</h1>

$$
% 设置
\newcommand{\aneg}[1]{\hspace{-0.75em}&#1&\hspace{-0.75em}}
\newcommand{\aneq}{\aneg{=}}
% 上述指令用于在使用 array 环境时调整等号左右间距
\newcommand{\noeq}{&\hspace{1.3em}}
% 上述指令用于 align 环境中, 类似与 &= 但不显示等号.
\renewcommand{\d}{\displaystyle}

% 字符
\renewcommand{\i}{\mathrm{i}}
\renewcommand{\j}{\mathrm{j}}
\renewcommand{\k}{\mathrm{k}}
\newcommand{\e}{\textup{e}}
\newcommand{\ve}{\varepsilon}
\newcommand{\Beta}{\mathrm{B}}
\newcommand{\omicron}{\mathit{o}}
\newcommand{\Omicron}{\mathrm{O}}

% 简写与重定义
\newcommand{\bm}[1]{\boldsymbol{#1}}
\renewcommand{\cal}[1]{\mathcal{#1}}
\renewcommand{\scr}[1]{\mathscr{#1}}
\renewcommand{\frak}[1]{\mathfrak{#1}}
\renewcommand{\rm}[1]{\mathrm{#1}}
\newcommand{\bb}[1]{\mathbb{#1}}

% 数集
\newcommand{\D}{\mathbb{D}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\J}{\mathbb{J}}
\newcommand{\K}{\mathbb{K}}
\renewcommand{\L}{\mathbb{L}}

% 上下标
\newcommand{\trans}{^\mathrm{T}}
\newcommand{\inv}{^{-1}}
\newcommand{\madj}[1]{^{\pqty{#1^*}}}	% m 重伴随矩阵
\newcommand{\adj}{^*}
\newcommand{\vector}[1]{\overrightarrow{#1}}
\newcommand{\wavy}[1]{\overset\sim#1}	% \tilde 或 \widetilde 不明显, 容易与 \bar 或 \overline 混淆

% 序列
\newcommand{\ccdots}{\cdot\cdots\cdot}
\newcommand{\oneton}{1,2,\cdots,n}
\newcommand{\oneto}[1]{1,2,\cdots,#1}

\newcommand{\ssto}[3]{#1_1 #3 #1_2 #3 \cdots #3 #1_{#2}}
\newcommand{\ssup}[3]{#1^1 #3 #1^2 #3 \cdots #3 #1^{#2}}
\newcommand{\soneto}[2]{\ssto{#1}{#2}{,}}
\newcommand{\splus}[2]{\ssto{#1}{#2}{+}}

% 括号
\newcommand{\aqty}[1]{\expval{#1}}
\newcommand{\pbqty}[1]{\left(#1\right]}
\newcommand{\bpqty}[1]{\left[#1\right)}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}

% 矩阵宏简写
\newcommand{\bmatrix}[1]{\begin{bmatrix}#1\end{bmatrix}}
\newcommand{\Bmatrix}[1]{\begin{Bmatrix}#1\end{Bmatrix}}
\newcommand{\vmatrix}[1]{\begin{vmatrix}#1\end{vmatrix}}
\newcommand{\Vmatrix}[1]{\begin{Vmatrix}#1\end{Vmatrix}}

% 常用微分
\newcommand{\dx}{\dd{x}}
\newcommand{\dy}{\dd{y}}
\newcommand{\dz}{\dd{z}}
\newcommand{\dt}{\dd{t}}
\newcommand{\ds}{\dd{s}}
\newcommand{\dr}{\dd{r}}

% 一般的微分
% 如果只使用 \dd{x}\dd{y} 的话, 中间会有多余的间隔.
\newcommand{\df}{\dd}
\newcommand{\ddf}[2]{\,\mathrm{d}#1\mathrm{d}#2}	% 微分形式 differential form
\newcommand{\dddf}[3]{\,\mathrm{d}#1\mathrm{d}#2\mathrm{d}#3}

% 高阶微分
\newcommand{\dxdy}{\ddf{x}{y}}
\newcommand{\dydz}{\ddf{y}{z}}
\newcommand{\dzdx}{\ddf{z}{x}}
\newcommand{\dudv}{\ddf{u}{v}}
\newcommand{\drdt}{\ddf{r}{\theta}}
\newcommand{\dxdydz}{\dddf{x}{y}{z}}

% 矩阵的宏指令
\newcommand{\pmcmn}[3]{\begin{pmatrix}
	#1_{11} & #1_{12} & \cdots & #1_{1#3} \\
	#1_{21} & #1_{22} & \cdots & #1_{n#3} \\
	\vdots & \vdots && \vdots \\
	#1_{#2 1} & #1_{#2 2} & \cdots & #2_{n#3} \\
\end{pmatrix}}

\newcommand{\pmc}[1]{\pmcmn{#1}{n}{n}}
\newcommand{\pvcn}[2]{\begin{pmatrix}
	#1_1 \\ #1_2 \\ \vdots \\ #1_{#2}
\end{pmatrix}}

\newcommand{\pvc}[1]{\pvcn{#1}{n}}
\newcommand{\pto}{\overset{P}{\to}}

% 函数名
\renewcommand{\char}{\operatorname{char}}	% 由于已存在此命令, 不可使用 DeclareMathOperator
\renewcommand{\r}{\operatorname{r}}
\DeclareMathOperator{\st}{s.t.\,}	% 虽然不是函数名, 但用了这个指令就放这儿了.
\DeclareMathOperator{\diag}{diag}	% 不需要定义太多, 一个文件里用到什么定义什么,
\DeclareMathOperator{\Ker}{Ker}		% 毕竟特殊的函数名太多太多了.
\DeclareMathOperator{\Aut}{Aut}		% 便捷与效率的权衡.
\DeclareMathOperator{\Inn}{Inn}
\DeclareMathOperator{\GL}{GL}
\DeclareMathOperator{\SL}{SL}
\DeclareMathOperator{\stab}{stab}
\DeclareMathOperator{\orb}{orb}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\Corr}{Corr}
\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Outer}{Outer}
\DeclareMathOperator{\Even}{Even}
\DeclareMathOperator{\Scalar}{Scalar}
\DeclareMathOperator{\Vector}{Vector}
\DeclareMathOperator{\arsh}{arsh}
\DeclareMathOperator{\arch}{arch}
\DeclareMathOperator{\arth}{arth}
\renewcommand{\Re}{\operatorname{Re}}	% 自带 \Re 的效果是 \mathrm{Re}, 前后无空格, 故重写
\renewcommand{\Im}{\operatorname{Im}}
\DeclareMathOperator{\Sa}{Sa}
\DeclareMathOperator{\Si}{Si}

% 运算符
% 可以用 \bigcap, \bigcup, \bigoplus, \bigotimes 替代
\newcommand{\capop}{\displaystyle\mathop\cap\limits}
\newcommand{\cupop}{\displaystyle\mathop\cup\limits}
\newcommand{\oplusop}{\mathop\oplus\limits}
\newcommand{\otimesop}{\mathop\otimes\limits}
\newcommand{\bigoplusop}{\mathop\bigoplus\limits}
\newcommand{\bigotimesop}{\mathop\bigotimes\limits}

% 积分
\newcommand{\dint}{\displaystyle\int}
\newcommand{\inti}{\dint_{-\infty}^{+\infty}}
\newcommand{\intoi}{\dint_0^{+\infty}}

\newcommand{\intl}{\displaystyle\int\limits}
\newcommand{\iintl}{\displaystyle\iint\limits}
\newcommand{\iiintl}{\displaystyle\iiint\limits}

% 求和
\newcommand{\dsum}{\displaystyle\sum}
\newcommand{\csum}[1]{\dsum_{#1=1}^\infty}
\newcommand{\nsum}{\csum{n}}
\newcommand{\ksum}{\csum{k}}
\newcommand{\nosum}{\dsum_{n=0}^\infty}
\newcommand{\insum}{\dsum_{i=1}^n}
\newcommand{\knsum}{\dsum_{k=1}^n}
\newcommand{\csuminf}[1]{\dsum_{#1=-\infty}^{+\infty}}
\newcommand{\nsuminf}{\csuminf{n}}

% 求积
\newcommand{\dprod}{\displaystyle\prod}
\newcommand{\nprod}{\dprod_{n=1}^\infty}
\newcommand{\noprod}{\dprod_{n=0}^\infty}
\newcommand{\inprod}{\dprod_{i=1}^n}

% 极限
\newcommand{\liml}{\lim\limits}
\newcommand{\ulim}{\overline\lim\limits_{n\to\infty}}
\newcommand{\dlim}{\underline\lim\limits_{n\to\infty}}
% 注意这里的 d 是 down, 而不是 displaystyle

\newcommand{\xlim}{\lim\limits_{x\to x_0}}
\newcommand{\nlim}{\lim\limits_{n\to\infty}}
\newcommand{\clim}[1]{\lim\limits_{#1\to\infty}}

% 并集
\newcommand{\incup}{\bigcup_{i=1}^n}
\newcommand{\ncup}{\bigcup_{n=1}^\infty}
\newcommand{\icup}{\bigcup_{i=1}^\infty}

% 交集
\newcommand{\incap}{\bigcap_{i=1}^n}
\newcommand{\ncap}{\bigcap_{n=1}^\infty}
\newcommand{\icap}{\bigcap_{i=1}^\infty}

% 差分
\newcommand{\DD}{\Delta}
\newcommand{\DV}[2]{\dfrac{\DD#1}{\DD#2}}
\newcommand{\nDV}[3]{\dfrac{\DD^{#1}#2}{\DD#3^{#1}}}

% 求导
\newcommand{\ddv}{\displaystyle\dv}
\newcommand{\dpdv}{\displaystyle\pdv}

% 最值 (返回参数); 暂时先这么凑合着用吧
\newcommand{\argmax}[1]{\underset{#1}{\operatorname{argmax}}}
\newcommand{\argmin}[1]{\underset{#1}{\operatorname{argmin}}}

% 缩写
\newcommand{\LRA}{\Leftrightarrow}
\newcommand{\RLA}{\Leftrightarrow}
\newcommand{\LA}{\Leftarrow}
\newcommand{\RA}{\Rightarrow}

\newcommand{\lra}{\leftrightarrow}
\newcommand{\rla}{\leftrightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\ra}{\rightarrow}

\newcommand{\QRLA}{\quad\RLA\quad}
\newcommand{\QRA}{\quad\RA\quad}
\newcommand{\LLRA}{\Longleftrightarrow}

\newcommand{\QNRA}{\quad\nRightarrow\quad}
\newcommand{\qnra}{\quad\nrightarrow\quad}

\newcommand{\wt}{\widetilde}

% 图形符号
\newcommand{\qed}{\quad\square}
\renewcommand{\parallel}{\mathrel{/\mskip-2.5mu/}}
\newcommand{\paralleleq}{\hspace{0.5em}{^{^{\parallel}}}\hspace{-1.04em}=}
\newcommand{\rt}{\matrm{Rt}\triangle}

% 分块矩阵
\newenvironment{mat}[1]{
	\begin{array}{#1}
}{
	\end{array}
}

\newenvironment{pmat}[1]{
	\left( \begin{array}{#1}
}{
	\end{array} \right)
}

\newenvironment{bmat}[1]{
	\left[ \begin{array}{#1}
}{
	\end{array} \right]
}

\newenvironment{Bmat}[1]{
	\left\{ \begin{array}{#1}
}{
	\end{array} \right\}
}

\newenvironment{vmat}[1]{
	\left\lvert \begin{array}{#1}
}{
	\end{array} \right\rvert
}

\newenvironment{Vmat}[1]{
	\left\lVert \begin{array}{#1}
}{
	\end{array} \right\rVert
}

% 积分变换
\newcommand{\ft}{\overset{\cal F}{\rla}}
\newcommand{\lt}{\overset{\cal L}{\rla}}
\newcommand{\bt}{\overset{\cal B}{\rla}}
\newcommand{\zt}{\overset{\cal Z}{\rla}}
\newcommand{\bzt}{\overset{\cal Z_B}{\rla}}
\newcommand{\lzt}{\overset{\cal Z_L}{\rla}}
\newcommand{\rzt}{\overset{\cal Z_R}{\rla}}

\newcommand{\cdelta}{\cdot\hspace{-0.55em}\Delta}
$$

#### 思考题

**（1） 有哪些常用的离散时间信号？**

1. 单位阶跃序列：$ u(n) = \bb I\Bqty{n \in \N} $.
2. 单位样值序列：$ \delta(n) = \bb I \Bqty{n = 0} $.
   1. 又称为单位脉冲序列、单位冲激序列.
   2. 相互关系
      1. $ \delta(n) = \nabla u(n) $.
      2. $ \delta(n+1) = \Delta u(n) $.
      3. $ u(n) = \dsum_{k=0}^\infty \delta(n - k) $.
      4. $ u(n+1) = 1 - \sum \delta(n) $.
   3. 序列性质
      1. $ x(n) \delta(n - k) = x(k) \delta(n - k) $.
      2. $ x(n) = \dsum_{k=-\infty}^\infty x(k) \delta(n-k) $.
      3. $ x(n) = x(n) \otimes \delta(n) $.
3. 单边指数序列：$ x(n) = a^n u(n) $.
4. 单边斜边序列：$ R(n) = n \cdot u(n) $.
5. 单位矩形序列
   1. $ G_N(n) = \bb I\Bqty{0 \le n < N} $.
   2. $ G_N(n) = u(n) - u(n - N) $.
   3. 注意区别于 $ G_\tau(t) $.
6. 正弦序列
   1. $ x(n) = \sin(n \omega T_\text s) = \sin(n \omega_0) $.
   2. 当且仅当 $ \dfrac{\omega_0}{2\pi} \in \Q $ 时，正弦序列为周期信号.
7. 复指数序列
   1. $ x(n) = \e^{\j\omega_0 n} = \cos(n \omega_0) + \j \sin(n \omega_0) $.
   2. 当且仅当 $ \dfrac{\omega_0}{2\pi} \in \Q $ 时，复指数序列为周期信号.



**（2） 单位阶跃序列和单位样值序列之间的关系是什么？**

见（1），

1. $ \delta(n) = \nabla u(n) $.
2. $ \delta(n+1) = \Delta u(n) $.
3. $ u(n) = \dsum_{k=0}^\infty \delta(n - k) $.
4. $ u(n+1) = 1 - \sum \delta(n) $.



**（3） 单边指数序列 $ a^n u(t) $ 按照 $ a $ 的不同可以分为哪几种情况？**

对于实数的情况：

1. 当 $ a < -1 $ 时，增长振荡.
2. 当 $ a = -1 $ 时，等幅振荡.
3. 当 $ -1 < a < 0 $ 时，衰减振荡.
4. 当 $ a = 0 $ 时，信号恒为零.
5. 当 $ 0 < a < 1 $ 时，衰减至零.
6. 当 $ a = 1 $ 时，即单位阶跃.
7. 当 $ a > 1 $ 时，增至无穷.



**（4） 为什么可以利用单位样值信号或移位的样值信号表示任意序列？**

利用单位样值信号的采样性质，
$$
\begin{align}
x(n) &= \csuminf k x(n) \delta(n - k)
= \csuminf k x(k) \delta(n - k)
= x(n) * \delta(n).
\end{align}
$$



**（5） 如何判断正弦序列的周期性？**

对于正弦序列 $ x(n) = \sin(n \omega T_\text s) = \sin(n \omega_0) $，当且仅当 $ \dfrac{\omega_0}{2\pi} \in \Q $ 时，正弦序列为周期信号.



**（6） 离散时间信号先压缩后展宽，是否能恢复出原信号？为什么？**

不一定，因为压缩会删点，而展宽只是补零，可能会丢失数据而无法恢复出原信号.



**（7） 什么是前向差分和后向差分？**

1. 一阶差分：
   1. 向前差分：$ \Delta f(n) = f(n+1) - f(n) $.
   2. 向后差分：$ \nabla f(n) = f(n) - f(n-1) $.
   3. 中心差分：$ \cdelta f(n) = \dfrac{f(n+1) - f(n-1)}{2} $.
2. 二阶差分：
   1. 向前差分：$ \Delta^2 f(n) = f(n+2) - 2 f(n+1) + f(n) $.
   2. 向后差分：$ \nabla^2 f(n) = f(n) - 2 f(n-1) + f(n-2) $.
   3. 中心差分：$ \cdelta^2 f(n) = \dfrac{f(n + 2) - 2f(n) + f(n-2)}{4} $.
3. 二元函数的五点差分公式：

$$
\begin{align}
\pqty{
	\pdv[2]{x} + \pdv[2]{y}
} f(x, y)
= \dfrac{
	f(x+h, y) + f(x, y+h) + f(x-h, y) + f(x, y-h) - 4f(x, y)
}{h^2}.
\end{align}
$$

**备注**	了解一阶的向前差分与向后差分即可，实际应用时 $ \sum_k \Delta^k f(n) $ 的形式可化为 $ \sum_k f(n - k) $ 的形式.



**（8） 模拟离散时间系统包括哪些基本运算单元？**

1. 加法器：$ \sum $.
2. 乘法器：$ \otimes $.
3. 标量乘法器：$ a $
4. 延时器：$ \dfrac{1}{E}, z\inv $.



**（9） 如何求解离散时间系统的齐次解和特解？**

本章研究线性时不变离散时间系统，即求解常系数线性差分方程.

1. 齐次解通过特征方程求解，根据特征根可分为 $m$ 重实根与 $m$ 重共轭复根的情况，如下表所示：

|                      特征根 $ \lambda $                      |                   齐次解 $ y_\text h(n) $                    |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                         $k$ 个单实根                         |              $ \dsum_{i=1}^k C_i \lambda_i^n $.              |
|                          $m$ 重实根                          | $ \lambda^n \pqty{A_0 + A_1 n + A_2 n^2 + \cdots + A_{m-1} n^{m-1}} $. |
| 共轭复根<br />$ \lambda = \alpha \pm \j\beta = \vqty{\lambda} \e^{\pm \j\varphi} $ | $ \vqty{\lambda}^n \bqty{A_1 \cos(n \varphi) + A_2 \sin(n \varphi)} $. |
|                        $m$ 重共轭复根                        |            在共轭复根的基础上，与 $m$ 重实根类似.            |

2. 特解可在齐次解的基础上使用拉格朗日常数变易法，也可以根据经验使用待定系数法，常见的激励形式及其特解形式如下表所示：

| 激励 $ x(n) $             | 特解 $ y_\text p(n) $                        | 说明               |
| ------------------------- | -------------------------------------------- | ------------------ |
| $ x(n) = \e^{an} $        | $ y_\text p(n) = A \e^{an} $                 | $ a \in \C $.      |
| $ x(n) = \cos(\omega n) $ | $ y_\text p(n) = A \cos(\omega n + \theta) $ | $ \omega \in \C $. |
| $ x(n) = \sin(\omega n) $ | $ y_\text p(n) = A \sin(\omega n + \theta) $ | $ \omega \in \C $. |
| $ x(n) = n^k $            | $ y_p(n) = \dsum_{i=0}^k A_i n^i $           | $ k \in \N $.      |
| $ x(n) = r^n $            | $ y_\text p(n) = C r^n $                     | $ r \in \C $.      |



**（10）什么是离散时间系统的零输入响应和零状态响应？**

与连续时间系统类似，全响应可分为零输入响应与零状态响应之和，即 $ y(n) = y_\text{zi}(n) + y_\text{zs}(n) $.

- 零输入响应 $ y_\text{zi}(n) $
  - 仅由初始状态 $ x(-1), x(-2), \cdots $ 引起.
  - 求解思路
    1. 解齐次差分方程，得到齐次通解 $ y_\text{zih}(n) $.
    2. 代入<span style="color: brown">初始状态</span> $ y(-1), y(-2), \cdots $，得到 $ y_\text{zi}(n) $.
- 零状态响应 $ y_\text{zs}(n) $
  - 仅由输入信号 $ x(n) $ 引起.
  - 思路 1
    1. 解非齐次差分方程，得到非齐次通解 $ y_\text{zsp}(n) $.
    2. 思路 1.1：用迭代法求得<span style="color: brown">初始值</span> $ y(0), y(1), \cdots $，代入后得到 $ y_\text{zs}(n) $.
    3. 思路 1.2：直接代入初始状态 $ 0 = y(-1) = y(-2) = \cdots $，得到 $ y_\text{zs}(n) $.
  - 思路 2：利用卷积和，$ y_\text{zs}(n) = x(n) * h(n) $.



#### 练习题

**2.1**	$ N = 11 $.

**备注**	对于连续函数，其最小正周期为 $ 5.5 $，但是离散序列的取值一般限定为 $ \Z $，故这里的周期应为 $11$.

---

**2.2**	$ N = 22 $.

---

**2.3**	由于 $ \dfrac{0.4}{2\pi} \notin \Q $，故该信号非周期信号.

---

**2.4**	

1. 压缩：$ x(2n) = \Bqty{\underline{1}, 3, 5, 7} $.
2. 扩展：$ x\pqty{\dfrac{n}{2}} = \{ \underset{\underset{n=0}{\uparrow}}{1}, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7 \} $.

**备注**	这里 $ \underline{1} $ 和 $ \underset{\underset{n=0}{\uparrow}}{1} $ 都表示 $ n = 0 $ 时的取值. 之后我都使用第一个表示方法，因为打字简单，且便于使用自适应括号.

---

**2.5**	$ y(n) - a y(n-1) = x(n) $.

**备注**	对于零状态的情况，可解得单位样值响应为 $ h(n) = a^n u(n) $，从而 $ y(n) = a^n u(n) * x(n) $.

---

**2.6**	$ y(n) - \dfrac{13}{4} y(n-1) + \dfrac{1}{8} y(n-2) = x(n) $.

---

**2.7**	

特征根为 2 和 3，从而 $ y(n) = C_1 2^n + C_2 3^n $，代入初值条件，得
$$
\begin{cases}
	y(0) = C_1 + C_2 = 2, \\
	y(1) = 2 C_1 + 3 C_2 = 1.
\end{cases} \QRA \begin{cases}
	C_1 = 5, \\
	C_2 = -3.
\end{cases}
$$
从而解为 $ y(n) = 5 \cdot 2^n - 3^{n+1} $.

---

**2.8**	

1. 零输入响应
   1. 特征根为 $-2$，故齐次通解为 $ y_\text{zih}(n) = C (-2)^n $.
   2. 代入 $ y(-1) = 1 $，得 $ y_\text{zi}(n) = (-2)^{n+1} $.
2. 零状态响应
   1. 零状态时迭代得 $ y(0) = 5 $，代入得 $ h(n) = 5 (-2)^n u(n) $.
   2. 于是 $ y_\text{zs}(n) = h(n) * u(n) = \dfrac{5}{3} \bqty{1 - (-2)^{n+1}} u(n) $.
3. 全响应：$ y(n) = y_\text{zi}(n) + y_\text{zs}(n) = (-2)^{n+1} + \dfrac{5}{3} \bqty{1 - (-2)^{n+1}} u(n) $.

---

**2.9**	

1. 求解零状态：递推得 $ y(-1) = -\dfrac{1}{2}, y(-2) = \dfrac{5}{4} $.
2. 求齐次通解：特征根为 $ -1, -2 $，于是 $ y_\text{zih}(n) = C_1 (-1)^n + C_2(-2)^n $.
3. 零输入响应：代入 $ y(-1) $ 和 $ y(-2) $，得 $ y_\text{zi}(n) = 2 (-1)^n - 3 (-2)^n $.



#### Mathematica 代码

**2.7**	

```mathematica
(* RSolve 用于解递推方程 *)
RSolve[{
		y[n] - 5 y[n - 1] + 6 y[n - 2] == 0,
		y[0] == 2, y[1] == 1
	}, y[n], n
]
```



**2.8**	

```mathematica
(* RSolveValue 用符号解差分方程，与 RSolve 功能类似，只是输出表达式，而非列表. *)
RSolve[{y[n] + 2 y[n - 1] == 5 UnitStep[n], y[-1] == 1}, y[n], n]
RSolveValue[{y[n] + 2 y[n - 1] == 5 UnitStep[n], y[-1] == 1}, y[n], n]
```



**2.9**	

```mathematica
x[n_] := (-2)^n UnitStep[n]

y1 = RSolveValue[{
		y[n] + 3 y[n - 1] + 2 y[n - 2] == x[n] + x[n - 1],
		y[0] == 0, y[1] == 0
	}, y[n], n
] (* 求解 x[n] 时的全响应 *)

RSolveValue[{
		y[n] + 3 y[n - 1] + 2 y[n - 2] == 0,
		y[-1] == y1 /. n -> -1,
		y[-2] == y1 /. n -> -2
	}, y[n], n
] (* 求解系统的零输入响应 *)
```

