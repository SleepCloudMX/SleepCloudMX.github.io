<p align="center">第三章 组合逻辑电路</p>

$$
% 设置
\newcommand{\aneg}[1]{\hspace{-0.75em}&#1&\hspace{-0.75em}}
\newcommand{\aneq}{\aneg{=}}
% 上述指令用于在使用 array 环境时调整等号左右间距
\newcommand{\eqs}{\quad\;}
% 上述指令用于 align 环境中, &= 的换行对齐时调整第二行位置
\renewcommand{\d}{\displaystyle}

% 字符
\renewcommand{\i}{\mathrm{i}}
\renewcommand{\j}{\mathrm{j}}
\renewcommand{\k}{\mathrm{k}}
\newcommand{\e}{\textup{e}}
\newcommand{\ve}{\varepsilon}
\newcommand{\Beta}{\mathrm{B}}
\newcommand{\omicron}{\mathit{o}}
\newcommand{\Omicron}{\mathit{O}}

% 原本的定义为:
% \newcommand{\cal}[1]{\mathcal{#1}}
\newcommand{\bm}[1]{\boldsymbol{#1}}
\renewcommand{\cal}[1]{\mathcal#1}
\renewcommand{\scr}[1]{\mathscr#1}
\renewcommand{\frak}[1]{\mathfrak#1}
\newcommand{\bb}[1]{\mathbb#1}

% 数集
\newcommand{\D}{\mathbb{D}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\J}{\mathbb{J}}
\newcommand{\K}{\mathbb{K}}
\renewcommand{\L}{\mathbb{L}}

% 上下标
\newcommand{\trans}{^\mathrm{T}}
\newcommand{\inv}{^{-1}}
\newcommand{\madj}[1]{^{\pqty{#1^*}}}	% m 重伴随矩阵
\newcommand{\adj}{^*}
\newcommand{\vector}[1]{\overrightarrow{#1}}
\newcommand{\wavy}[1]{\overset\sim#1}	% \tilde 或 \widetilde 不明显, 容易与 \bar 或 \overline 混淆

% 序列
\newcommand{\ccdots}{\cdot\cdots\cdot}
\newcommand{\oneton}{1,2,\cdots,n}
\newcommand{\oneto}[1]{1,2,\cdots,#1}

\newcommand{\ssto}[3]{#1_1 #3 #1_2 #3 \cdots #3 #1_{#2}}
\newcommand{\ssup}[3]{#1^1 #3 #1^2 #3 \cdots #3 #1^{#2}}
\newcommand{\soneto}[2]{\ssto{#1}{#2}{,}}
\newcommand{\splus}[2]{\ssto{#1}{#2}{+}}

% 括号
\newcommand{\aqty}[1]{\expval{#1}}
\newcommand{\pbqty}[1]{\left(#1\right]}
\newcommand{\bpqty}[1]{\left[#1\right)}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}

% 矩阵宏简写
\newcommand{\bmatrix}[1]{\begin{bmatrix}#1\end{bmatrix}}
\newcommand{\Bmatrix}[1]{\begin{Bmatrix}#1\end{Bmatrix}}
\newcommand{\vmatrix}[1]{\begin{vmatrix}#1\end{vmatrix}}
\newcommand{\Vmatrix}[1]{\begin{Vmatrix}#1\end{Vmatrix}}

% 常用微分
\newcommand{\dx}{\dd{x}}
\newcommand{\dy}{\dd{y}}
\newcommand{\dz}{\dd{z}}
\newcommand{\dt}{\dd{t}}
\newcommand{\ds}{\dd{s}}
\newcommand{\dr}{\dd{r}}

% 一般的微分
% 如果只使用 \dd{x}\dd{y} 的话, 中间会有多余的间隔.
\newcommand{\df}{\dd}
\newcommand{\ddf}[2]{\,\mathrm{d}#1\mathrm{d}#2}	% 微分形式 differential form
\newcommand{\dddf}[3]{\,\mathrm{d}#1\mathrm{d}#2\mathrm{d}#3}

% 高阶微分
\newcommand{\dxdy}{\ddf{x}{y}}
\newcommand{\dydz}{\ddf{y}{z}}
\newcommand{\dzdx}{\ddf{z}{x}}
\newcommand{\dudv}{\ddf{u}{v}}
\newcommand{\drdt}{\ddf{r}{\theta}}
\newcommand{\dxdydz}{\dddf{x}{y}{z}}

% 矩阵的宏指令
\newcommand{\pmcmn}[3]{\begin{pmatrix}
	#1_{11} & #1_{12} & \cdots & #1_{1#3} \\
	#1_{21} & #1_{22} & \cdots & #1_{n#3} \\
	\vdots & \vdots && \vdots \\
	#1_{#2 1} & #1_{#2 2} & \cdots & #2_{n#3} \\
\end{pmatrix}}

\newcommand{\pmc}[1]{\pmcmn{#1}{n}{n}}
\newcommand{\pvcn}[2]{\begin{pmatrix}
	#1_1 \\ #1_2 \\ \vdots \\ #1_{#2}
\end{pmatrix}}

\newcommand{\pvc}[1]{\pvcn{#1}{n}}
\newcommand{\pto}{\overset{P}{\to}}

% 函数名
\renewcommand{\char}{\operatorname{char}}	% 由于已存在此命令, 不可使用 DeclareMathOperator
\renewcommand{\r}{\operatorname{r}}
\DeclareMathOperator{\st}{s.t.\,}	% 虽然不是函数名, 但用了这个指令就放这儿了.
\DeclareMathOperator{\diag}{diag}	% 不需要定义太多, 一个文件里用到什么定义什么,
\DeclareMathOperator{\Ker}{Ker}		% 毕竟特殊的函数名太多太多了.
\DeclareMathOperator{\Aut}{Aut}		% 便捷与效率的权衡.
\DeclareMathOperator{\Inn}{Inn}
\DeclareMathOperator{\GL}{GL}
\DeclareMathOperator{\SL}{SL}
\DeclareMathOperator{\stab}{stab}
\DeclareMathOperator{\orb}{orb}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\Corr}{Corr}
\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Outer}{Outer}
\DeclareMathOperator{\Even}{Even}
\DeclareMathOperator{\Scalar}{Scalar}
\DeclareMathOperator{\Vector}{Vector}
\DeclareMathOperator{\arsh}{arsh}
\DeclareMathOperator{\arch}{arch}
\DeclareMathOperator{\arth}{arth}
\renewcommand{\Re}{\operatorname{Re}}	% 自带 \Re 的效果是 \mathrm{Re}, 前后无空格, 故重写
\renewcommand{\Im}{\operatorname{Im}}
\DeclareMathOperator{\Sa}{Sa}
\DeclareMathOperator{\Si}{Si}

% 运算符
% 可以用 \bigcap, \bigcup, \bigoplus, \bigotimes 替代
\newcommand{\capop}{\displaystyle\mathop\cap\limits}
\newcommand{\cupop}{\displaystyle\mathop\cup\limits}
\newcommand{\oplusop}{\mathop\oplus\limits}
\newcommand{\otimesop}{\mathop\otimes\limits}
\newcommand{\bigoplusop}{\mathop\bigoplus\limits}
\newcommand{\bigotimesop}{\mathop\bigotimes\limits}

% 积分
\newcommand{\dint}{\displaystyle\int}
\newcommand{\inti}{\dint_{-\infty}^{+\infty}}
\newcommand{\intoi}{\dint_0^{+\infty}}

\newcommand{\intl}{\displaystyle\int\limits}
\newcommand{\iintl}{\displaystyle\iint\limits}
\newcommand{\iiintl}{\displaystyle\iiint\limits}

% 求和
\newcommand{\dsum}{\displaystyle\sum}
\newcommand{\csum}[1]{\dsum_{#1=1}^\infty}
\newcommand{\nsum}{\csum{n}}
\newcommand{\nsuminf}{\dsum_{n=-\infty}^{+\infty}}
\newcommand{\ksum}{\csum{k}}
\newcommand{\nosum}{\dsum_{n=0}^\infty}
\newcommand{\insum}{\dsum_{i=1}^n}
\newcommand{\knsum}{\dsum_{k=1}^n}

% 求积
\newcommand{\dprod}{\displaystyle\prod}
\newcommand{\nprod}{\dprod_{n=1}^\infty}
\newcommand{\noprod}{\dprod_{n=0}^\infty}
\newcommand{\inprod}{\dprod_{i=1}^n}

% 极限
\newcommand{\liml}{\lim\limits}
\newcommand{\ulim}{\overline\lim\limits_{n\to\infty}}
\newcommand{\dlim}{\underline\lim\limits_{n\to\infty}}
% 注意这里的 d 是 down, 而不是 displaystyle

\newcommand{\xlim}{\lim\limits_{x\to x_0}}
\newcommand{\nlim}{\lim\limits_{n\to\infty}}
\newcommand{\clim}[1]{\lim\limits_{#1\to\infty}}

% 并集
\newcommand{\incup}{\bigcup_{i=1}^n}
\newcommand{\ncup}{\bigcup_{n=1}^\infty}
\newcommand{\icup}{\bigcup_{i=1}^\infty}

% 交集
\newcommand{\incap}{\bigcap_{i=1}^n}
\newcommand{\ncap}{\bigcap_{n=1}^\infty}
\newcommand{\icap}{\bigcap_{i=1}^\infty}

% 差分
\newcommand{\DD}{\Delta}
\newcommand{\DV}[2]{\dfrac{\DD#1}{\DD#2}}
\newcommand{\nDV}[3]{\dfrac{\DD^{#1}#2}{\DD#3^{#1}}}

% 求导
\newcommand{\ddv}{\displaystyle\dv}
\newcommand{\dpdv}{\displaystyle\pdv}

% 最值 (返回参数); 暂时先这么凑合着用吧
\newcommand{\argmax}[1]{\underset{#1}{\operatorname{argmax}}}
\newcommand{\argmin}[1]{\underset{#1}{\operatorname{argmin}}}

% 缩写
\newcommand{\LRA}{\Leftrightarrow}
\newcommand{\RLA}{\Leftrightarrow}
\newcommand{\LA}{\Leftarrow}
\newcommand{\RA}{\Rightarrow}

\newcommand{\lra}{\leftrightarrow}
\newcommand{\rla}{\leftrightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\ra}{\rightarrow}

\newcommand{\QRLA}{\quad\RLA\quad}
\newcommand{\QRA}{\quad\RA\quad}
\newcommand{\LLRA}{\Longleftrightarrow}

\newcommand{\QNRA}{\quad\nRightarrow\quad}
\newcommand{\qnra}{\quad\nrightarrow\quad}

\newcommand{\wt}{\widetilde}

% 图形符号
\newcommand{\qed}{\quad\square}
\renewcommand{\parallel}{\mathrel{/\mskip-2.5mu/}}
\newcommand{\paralleleq}{\hspace{0.5em}{^{^{\parallel}}}\hspace{-1.04em}=}
\newcommand{\rt}{\matrm{Rt}\triangle}

% 分块矩阵
\newenvironment{mat}[1]{
	\begin{array}{#1}
}{
	\end{array}
}

\newenvironment{pmat}[1]{
	\left( \begin{array}{#1}
}{
	\end{array} \right)
}

\newenvironment{bmat}[1]{
	\left[ \begin{array}{#1}
}{
	\end{array} \right]
}

\newenvironment{Bmat}[1]{
	\left\{ \begin{array}{#1}
}{
	\end{array} \right\}
}

\newenvironment{vmat}[1]{
	\left\lvert \begin{array}{#1}
}{
	\end{array} \right\rvert
}

\newenvironment{Vmat}[1]{
	\left\lVert \begin{array}{#1}
}{
	\end{array} \right\rVert
}
$$

[TOC]

## 第 3 章  组合逻辑电路

### 3.1  组合逻辑电路的简介

- 数字电路

  - 按功能特点分类

    - 组合逻辑电路
    - 时序逻辑电路

  - 按集成度分类

    - 小规模集成电路 (SSI, small scale integrated circuits)

    - 中规模集成电路 (MSI, medium scale integrated circuits)

    - 大规模集成电路 (LSI, large scale integrated circuits)

    - 超大规模集成电路 (VLSI, very large scale integrated circuites)

- 计算机管理教学 (CMI, computer managed instruction)
- 计算机辅助教学 (CAI, computer assisted instruction)

### 3.2  组合逻辑电路的分析与设计

#### 3.2.1  SSI 组合逻辑电路的分析

步骤

1. 电路图 -> 表达式.
2. 化简表达式.
3. 列出真值表.
4. 分析、确定功能.

#### 3.2.2  SSI 组合逻辑电路的设计

步骤

1. 明确功能, 确定变量个数.
2. 列真值表.
3. 写函数表达式.
4. 化简并画出逻辑图.

设计四位奇检验电路 (出现奇数个 1 则输出为 1)

$ L = A \oplus B \oplus C \oplus D $.

设计四位二进制取反加 1 电路

### 3.3  组合逻辑电路中的竞争与冒险

#### 3.3.1  产生的原因

由于延时而产生竞争, 如果可能产生错误, 则称该竞争为冒险.

若某种输入导致运算中含有 $ A + \overline A $ 和 $ A \overline A $, 则会产生冒险.

#### 3.3.2  消除的方法

1. 改变表达式的形式
2. 增加冗余项 (如果有相切的则用圈连接起来)
3. 在输出端并接电容: 在消除毛刺的情况下, 电容要尽可能小.

### 3.4  组合逻辑集成电路

#### 3.4.1  编码器

信息 -> 二进制 (输出少)

- 普通编码器

  - 二进制编码器
    - 以 8-3 为例 $ \begin{cases}
      	Y_2 = I_4 + I_5 + I_6 + I_7, \\
      	Y_1 = I_2 + I_3 + I_6 + I_7, \\
      	Y_0 = I_1 + I_3 + I_5 + I_7.
      \end{cases} $ 
  - 十进制编码器 (二-十进制有限编码器)
    - 即 10-4 编码器
    - 含标志位 GS: 有输入即为 1.
- 优先编码器

  - 以 4-2 编码器为例 $ \begin{cases}
    	Y_1 = I_3 + \overline{I}_3 I_2 = I_3 + I_2, \\
    	Y_0 = I_3 + \overline{I}_3 \overline{I}_2 I_1 = I_3 + \overline{I}_2 I_1.
    \end{cases} $ 
- 集成电路编码器

  - 优先编码器 CD4532 (8-3)
    - I~7~, ..., I~0~, GS, Y~2~, Y~1~, Y~0~, EI, EO.
    - 输入使能端 EI = 0, 输出恒为零.
    - EI = 1, 无输入, 则 EO = 1.
    - EI = 1, 有输入, 则 GS = 1, EO = 0.
  - 两片 CD4532 实现 16-4
  - 优先编码器 74HC148 (8-3)
    - I~7~, ..., I~0~, Y'~ES~, Y'~2~, Y'~1~, Y'~0~, S', Y'~S~.
    - 选通输入端 S' = 1, 所有输出端被封锁在高电平. (如 Y'~0~ = 1)
    - S' = 0, 无输入, 则 Y'~S~ = 0.
    - S' = 0, 有输入, 则 Y'~EX~ = 0, Y'~S~ = 1.
  - 优先编码器 74HC147 (10-4)
    - I'~9~, ..., I'~0~, Y'~3~, ..., Y'~0~.
- 注意: <u>使能端即使不用, 也要接地.</u>

#### 3.4.2  译码器

二进制 -> 信息 (输入少)

- 二进制译码器

  - 74LS139 双二线四线译码器 (低电平有效)

    1/2 74LS139

    - E', A~0~, A~1~, Y'~0~, ..., Y'~3~.
    - E' = 1, 所有输出端被封锁在高电平.
    - E' = 0, 正常输出 (注意低电平有效)

  - 74LS138 (3-8) (低电平有效) :star: 

    - E~3~, E'~2~, E'~1~, A~0~, A~1~, A~2~, Y'~0~, ..., Y'~7~.

      注意 E~3~ 没有非号.

    - 只有 E~3~, E~1~, E~1~ 为 1, 1, 0 时才正常输出.

  - 74LS138 的应用

    - 扩展 (5 线 - 32 线): 利用使能端.
    - 实现三变量的逻辑函数.
    - 数据分配器

- 十进制译码器 (二-十进制译码器)

- 显示译码器 (代码转化器)

  - 数码重迭式
  - 点阵式
  - 分段式: 七段显示器
    - 共阴
      - CD4511
        - 输出: a, b, c, d, e, f, g
        - 输入: A~3~, ..., A~0~.
        - 控制端 LT', BL', LE
        - 若 LT' = 0, 则都亮.
        - 若 LT' = 1, BL = 0, 则灭灯.
        - 若 LT' = BL' = LE' = 1, 则为锁存.
        - 若 LT' = 1, BL' = 1, LE = 0, 则为正常状态.

    - 共阳

#### 3.4.3  数据选择器

- 数据分配器: 单输入, 多输出
- 数据选择器 (MUX): 多输入, 单输出

**集成数据选择器**

- 74HC151 八选一
  - I~0~, ..., I~7~, A~2~, A~1~, A~0~, EN, L, L'
  - L 和 L' 为输出端, A~i~ 为控制端, EN 为使能端.
  - 若 EN = 1, 则输出恒为零.
  - 若 EN = 0, 则正常输出.
- 74LS153 双四选一
  - 共用使能端
- 应用
  - 实现逻辑函数 (通过 151 或 153)
    - 法一, 若 A 和 B 作为控制端, 则将逻辑函数表示为 A'B' () + A'B () + ...
    - 法二: 利用卡诺图 (注意顺序)
  - 扩展: 四选一 -> 十六选一
    - 法一: 四个四选一, 输出四线, 再加一个四选一.
    - 法二: 四个四选一, 利用对使能端的控制实现只有一个输出.
  - 并行输入 -> 串行输出

#### 3.4.4  比较器

- 1 位二进制比较器
  - A, B, F~A>B~, F~A=B~, F~A<B~.
  - 输出
    - F~A>B~ = AB'.
    - F~A=B~ = A'B.
    - F~A<B~ = A'B' + AB.
  - 结果的互斥性
    - F~A=B~ = (F~A>B~ + F~A<B~)'.
    - 其余同理.
- 2 位二进制比较器
  - A = A~1~A~0~, B = B~1~B~0~.
  - F~A>B~ = (A~1~>B~1~) + (A~1~=B~1~) (A~0~>B~0~).
  - F~A=B~ = (A~1~=B~1~) (A~0~=B~0~).
  - F~A<B~ = (A~1~<B~1~) + (A~1~=B~1~) (A~0~<B~0~).
- 集成载值比较器
  - 74LS<u>85</u> (四位)
    - A = A~3~A~2~A~1~A~0~.
    - B = B~3~B~2~B~1~B~0~.
    - 级间输入: I~A>B~, I~A=B~, I~A<B~.
  - 74LS85 的扩展 (比较 2^n^ 位数字)
    - 串联: 需要 2^n-2^ 个芯片, 需要 2^n-2^ 个单位时间.
    - 并联: 需要的芯片数更多, 但是需要的时间更短.

#### 3.4.4  算术运算电路

- 一位加法器

  - 半加器 HA

    - 两个输入端: A, B.
    - 两个输出端: 和端 S, 进位端 C.
    - S = A'B + AB' = A $ \oplus $ B.
    - C = AB.

  - 全加器 FA

    - 三个输入端: A~i~, B~i~, C~i-1~.

    - 两个输出端: S~i~, C~i~.

    - 实现思路 1 和 2 (略去下标)

      - S~i~ = A'B'C + A'BC' + AB'C' + ABC = A $ \oplus $ B $ \oplus $ C.

        注: 只有输入奇数个 1, 才会输出 1, 于是可用全加器判断奇偶.

      - C~i~ = AB + BC + AC = (A $ \oplus $ B) C + AB.

        注: 只有输入超过一个 1, 才会输出 1.

    - 实现思路 3: 利用两个半加器.

- 多位加法器

  - 串行加法 (慢)
  - 超前进位: 由递推式逐项展开.

- 集成块 74LS283 (超前进位四位加法器) 的应用

  - 8 位二进制数相加: 两个芯片的串行.
  - 8421 BCD 码 -> 余 3 码. (即各位 + 3)

- 减法器

  - 欲计算 A - B, 将 A 与 B 取为补码后相加, 注意进位, 结果再次取为补码.

#### 3.4.5  组合可编程逻辑器件

- PLD (Programmable Logic Device) 的结构

$$
\xymatrix{
	\ar[r]^-{输入信号} &
	\boxed{输入电路} \ar[r]^-{互补输入} &
	\boxed{与门阵列} \ar[r]^-{乘积项} &
	\boxed{或门阵列} \ar[r]^-{和项} &
	\boxed{输出电路} \ar[r]^-{输出函数} \ar@{-}[d] &
	\\
	&
	\ar[u] &
	\ar@{-}[l] &
	\ar@{-}[l]_-{反馈输入} &
	\ar@{-}[l] &
}
$$

- PLD 的表示方式

  - 连接方式

    - 实心点 (不可编程)
    - 叉点 (可以编程)
    - 无点 (未相连)

  - 基本门电路的表示方式

    <img src="image/4.5 PLD 的表示方法-1682130938038-1.png" alt="PLD 的表示方法" style="zoom:72%;" />

  - 编程技术: 二极管 + 熔丝工艺.

- PLD 的分类

  - 低密度 PLD (LD)
    - PROM: 可编程只读存储器 (programmable read-only memory).
      - 与阵列固定, 或阵列可编程.
    - PLA: 可编程逻辑阵列 (programmable logic array).
      - 与或阵列可编程.
    - PAL: 可编程阵列逻辑 (programmable array logic)
      - 与阵列可编程, 或阵列固定.
    - GAL: 通用阵列逻辑 (general array logic)
      - 与阵列可编程, 或阵列固定.
  - 高密度 PLD (HD)
    - EPLD
    - CPLD
    - FPGA

- 组合逻辑电路的 PLD 实现 (以全加器为例)

<img src="image/4.5 组合逻辑电路的 PLD 实现.png" alt="image-20230402173213823" style="zoom:72%;" />