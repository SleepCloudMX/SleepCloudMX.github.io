<h2 align="center">第一章作业</h2>

$$
% 设置
\renewcommand{\d}{\displaystyle}
\newcommand{\aneg}[1]{\hspace{-0.75em}&#1&\hspace{-0.75em}\d}
\newcommand{\aneq}{\aneg{=}}
\newcommand{\overaneg}[2]{\hspace{-0.75em}&\overset{#1}{#2}&\hspace{-0.75em}\d}
\newcommand{\overaneq}[1]{\overaneg{#1}{=}}
% 上述指令用于在使用 array 环境时调整等号左右间距
\newcommand{\noeq}{&\hspace{1.3em}}
% 上述指令用于 align 环境中, 类似与 &= 但不显示等号.
\newcommand{\ltag}[1]{\label{#1}\tag{#1}}

% 字符
\renewcommand{\i}{\mathrm{i}}
\renewcommand{\j}{\mathrm{j}}
\renewcommand{\k}{\mathrm{k}}
\newcommand{\e}{\mathrm{e}}
\newcommand{\o}{\mathrm{o}}
\newcommand{\ve}{\varepsilon}
\newcommand{\Beta}{\mathrm{B}}
\newcommand{\omicron}{\mathit{o}}
\newcommand{\Omicron}{\mathrm{O}}
\newcommand{\ver}{\ve_\rm r}

% 简写与重定义
\newcommand{\bm}[1]{\boldsymbol{#1}}
\renewcommand{\cal}[1]{\mathcal{#1}}
\renewcommand{\scr}[1]{\mathscr{#1}}
\renewcommand{\frak}[1]{\mathfrak{#1}}
\renewcommand{\rm}[1]{\mathrm{#1}}
\newcommand{\bb}[1]{\mathbb{#1}}

% 数集
\newcommand{\D}{\mathbb{D}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\J}{\mathbb{J}}
\newcommand{\K}{\mathbb{K}}
\renewcommand{\L}{\mathbb{L}}

% 上下标
\newcommand{\trans}{^\mathrm{T}}
\newcommand{\conj}{^\rm{H}}
\newcommand{\inv}{^{-1}}
\newcommand{\madj}[1]{^{\pqty{#1^*}}}	% m 重伴随矩阵
\newcommand{\adj}{^*}
\newcommand{\vector}[1]{\overrightarrow{#1}}
\newcommand{\wavy}[1]{\overset\sim#1}	% \tilde 或 \widetilde 不明显, 容易与 \bar 或 \overline 混淆

% 序列
\newcommand{\ccdots}{\cdot\cdots\cdot}
\newcommand{\oneton}{1,2,\cdots,n}
\newcommand{\oneto}[1]{1,2,\cdots,#1}

\newcommand{\ssto}[3]{#1_1 #3 #1_2 #3 \cdots #3 #1_{#2}}
\newcommand{\ssup}[3]{#1^1 #3 #1^2 #3 \cdots #3 #1^{#2}}
\newcommand{\soneto}[2]{\ssto{#1}{#2}{,}}
\newcommand{\splus}[2]{\ssto{#1}{#2}{+}}

% 括号
\newcommand{\aqty}[1]{\expval{#1}}
\newcommand{\pbqty}[1]{\left(#1\right]}
\newcommand{\bpqty}[1]{\left[#1\right)}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\Norm}[1]{\norm\big{#1}}
\newcommand{\Angle}[1]{\left|\hspace{-0.1em}\underline{\hspace{0.1em}#1}\right.}

% 矩阵宏简写
\newcommand{\bmatrix}[1]{\begin{bmatrix}#1\end{bmatrix}}
\newcommand{\Bmatrix}[1]{\begin{Bmatrix}#1\end{Bmatrix}}
\newcommand{\vmatrix}[1]{\begin{vmatrix}#1\end{vmatrix}}
\newcommand{\Vmatrix}[1]{\begin{Vmatrix}#1\end{Vmatrix}}

% 常用微分
\newcommand{\dx}{\dd{x}}
\newcommand{\dy}{\dd{y}}
\newcommand{\dz}{\dd{z}}
\newcommand{\dt}{\dd{t}}
\newcommand{\ds}{\dd{s}}
\newcommand{\dr}{\dd{r}}

% 一般的微分
% 如果只使用 \dd{x}\dd{y} 的话, 中间会有多余的间隔.
\newcommand{\df}{\dd}
\newcommand{\ddf}[2]{\,\mathrm{d}#1\mathrm{d}#2}	% 微分形式 differential form
\newcommand{\dddf}[3]{\,\mathrm{d}#1\mathrm{d}#2\mathrm{d}#3}

% 高阶微分
\newcommand{\dxdy}{\ddf{x}{y}}
\newcommand{\dydz}{\ddf{y}{z}}
\newcommand{\dzdx}{\ddf{z}{x}}
\newcommand{\dudv}{\ddf{u}{v}}
\newcommand{\drdt}{\ddf{r}{\theta}}
\newcommand{\dxdydz}{\dddf{x}{y}{z}}

% 矩阵的宏指令
\newcommand{\pmcmn}[3]{\begin{pmatrix}
	#1_{11} & #1_{12} & \cdots & #1_{1#3} \\
	#1_{21} & #1_{22} & \cdots & #1_{n#3} \\
	\vdots & \vdots && \vdots \\
	#1_{#2 1} & #1_{#2 2} & \cdots & #2_{n#3} \\
\end{pmatrix}}

\newcommand{\pmc}[1]{\pmcmn{#1}{n}{n}}
\newcommand{\pvcn}[2]{\begin{pmatrix}
	#1_1 \\ #1_2 \\ \vdots \\ #1_{#2}
\end{pmatrix}}

\newcommand{\pvc}[1]{\pvcn{#1}{n}}
\newcommand{\pto}{\overset{P}{\to}}

% 函数名
\renewcommand{\char}{\operatorname{char}}	% 由于已存在此命令, 不可使用 DeclareMathOperator
\renewcommand{\r}{\operatorname{r}}
\DeclareMathOperator{\st}{s.t.\,}	% 虽然不是函数名, 但用了这个指令就放这儿了.
\DeclareMathOperator{\diag}{diag}	% 不需要定义太多, 一个文件里用到什么定义什么,
\DeclareMathOperator{\Ker}{Ker}		% 毕竟特殊的函数名太多太多了.
\DeclareMathOperator{\Aut}{Aut}		% 便捷与效率的权衡.
\DeclareMathOperator{\Inn}{Inn}
\DeclareMathOperator{\GL}{GL}
\DeclareMathOperator{\SL}{SL}
\DeclareMathOperator{\stab}{stab}
\DeclareMathOperator{\orb}{orb}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\Corr}{Corr}
\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Outer}{Outer}
\DeclareMathOperator{\Even}{Even}
\DeclareMathOperator{\Scalar}{Scalar}
\DeclareMathOperator{\Vector}{Vector}
\DeclareMathOperator{\arsh}{arsh}
\DeclareMathOperator{\arch}{arch}
\DeclareMathOperator{\arth}{arth}
\renewcommand{\Re}{\operatorname{Re}}	% 自带 \Re 的效果是 \mathrm{Re}, 前后无空格, 故重写
\renewcommand{\Im}{\operatorname{Im}}
\DeclareMathOperator{\Sa}{Sa}
\DeclareMathOperator{\Si}{Si}
\DeclareMathOperator{\avg}{avg}
\DeclareMathOperator{\cond}{cond}

% 运算符
% 可以用 \bigcap, \bigcup, \bigoplus, \bigotimes 替代
\newcommand{\capop}{\displaystyle\mathop\cap\limits}
\newcommand{\cupop}{\displaystyle\mathop\cup\limits}
\newcommand{\oplusop}{\mathop\oplus\limits}
\newcommand{\otimesop}{\mathop\otimes\limits}
\newcommand{\bigoplusop}{\mathop\bigoplus\limits}
\newcommand{\bigotimesop}{\mathop\bigotimes\limits}

% 积分
\newcommand{\dint}{\displaystyle\int}
\newcommand{\inti}{\dint_{-\infty}^{+\infty}}
\newcommand{\intoi}{\dint_0^{+\infty}}

\newcommand{\intl}{\displaystyle\int\limits}
\newcommand{\iintl}{\displaystyle\iint\limits}
\newcommand{\iiintl}{\displaystyle\iiint\limits}

\newcommand{\coiint}[1]{\d{\oiint\hspace{-1em}}_{#1}\;}
\newcommand{\coiiint}[1]{\d{\oiiint\hspace{-0.9em}}_{#1}\;}

% 求和
\newcommand{\dsum}{\displaystyle\sum}
\newcommand{\csum}[1]{\dsum_{#1=1}^\infty}
\newcommand{\nsum}{\csum{n}}
\newcommand{\ksum}{\csum{k}}
\newcommand{\nosum}{\dsum_{n=0}^\infty}
\newcommand{\insum}{\dsum_{i=1}^n}
\newcommand{\knsum}{\dsum_{k=1}^n}
\newcommand{\csuminf}[1]{\dsum_{#1=-\infty}^{+\infty}}
\newcommand{\nsuminf}{\csuminf{n}}

% 求积
\newcommand{\dprod}{\displaystyle\prod}
\newcommand{\nprod}{\dprod_{n=1}^\infty}
\newcommand{\noprod}{\dprod_{n=0}^\infty}
\newcommand{\inprod}{\dprod_{i=1}^n}

% 极限
\newcommand{\liml}{\lim\limits}
\newcommand{\ulim}{\overline\lim\limits_{n\to\infty}}
\newcommand{\dlim}{\underline\lim\limits_{n\to\infty}}
% 注意这里的 d 是 down, 而不是 displaystyle

\newcommand{\xlim}{\lim\limits_{x\to x_0}}
\newcommand{\nlim}{\lim\limits_{n\to\infty}}
\newcommand{\clim}[1]{\lim\limits_{#1\to\infty}}

% 并集
\newcommand{\incup}{\bigcup_{i=1}^n}
\newcommand{\ncup}{\bigcup_{n=1}^\infty}
\newcommand{\icup}{\bigcup_{i=1}^\infty}

% 交集
\newcommand{\incap}{\bigcap_{i=1}^n}
\newcommand{\ncap}{\bigcap_{n=1}^\infty}
\newcommand{\icap}{\bigcap_{i=1}^\infty}

% 差分
\newcommand{\DD}{\Delta}
\newcommand{\DV}[2]{\dfrac{\DD#1}{\DD#2}}
\newcommand{\nDV}[3]{\dfrac{\DD^{#1}#2}{\DD#3^{#1}}}

% 求导
\newcommand{\ddv}{\displaystyle\dv}
\newcommand{\dpdv}{\displaystyle\pdv}

% 最值 (返回参数); 暂时先这么凑合着用吧
\newcommand{\argmax}[1]{\underset{#1}{\operatorname{argmax}}}
\newcommand{\argmin}[1]{\underset{#1}{\operatorname{argmin}}}

% 缩写
\newcommand{\LRA}{\Leftrightarrow}
\newcommand{\RLA}{\Leftrightarrow}
\newcommand{\LA}{\Leftarrow}
\newcommand{\RA}{\Rightarrow}

\newcommand{\lra}{\leftrightarrow}
\newcommand{\rla}{\leftrightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\ra}{\rightarrow}

\newcommand{\QRLA}{\quad\RLA\quad}
\newcommand{\QRA}{\quad\RA\quad}
\newcommand{\LLRA}{\Longleftrightarrow}

\newcommand{\QNRA}{\quad\nRightarrow\quad}
\newcommand{\qnra}{\quad\nrightarrow\quad}

\newcommand{\wt}{\widetilde}

% 图形符号
\newcommand{\qed}{\quad\square}
\renewcommand{\parallel}{\mathrel{/\mskip-2.5mu/}}
\newcommand{\paralleleq}{\hspace{0.5em}{^{^{\parallel}}}\hspace{-1.04em}=}
\newcommand{\rt}{\matrm{Rt}\triangle}

% 分块矩阵
\newenvironment{mat}[1]{
	\begin{array}{#1}
}{
	\end{array}
}

\newenvironment{pmat}[1]{
	\left( \begin{array}{#1}
}{
	\end{array} \right)
}

\newenvironment{bmat}[1]{
	\left[ \begin{array}{#1}
}{
	\end{array} \right]
}

\newenvironment{Bmat}[1]{
	\left\{ \begin{array}{#1}
}{
	\end{array} \right\}
}

\newenvironment{vmat}[1]{
	\left\lvert \begin{array}{#1}
}{
	\end{array} \right\rvert
}

\newenvironment{Vmat}[1]{
	\left\lVert \begin{array}{#1}
}{
	\end{array} \right\rVert
}

% 积分变换
\newcommand{\ft}{\overset{\cal F}{\rla}}
\newcommand{\dtft}{\overset{\rm F}{\rla}}
\newcommand{\lt}{\overset{\cal L}{\rla}}
\newcommand{\bt}{\overset{\cal B}{\rla}}
\newcommand{\zt}{\overset{\cal Z}{\rla}}
\newcommand{\bzt}{\overset{\cal Z_B}{\rla}}
\newcommand{\lzt}{\overset{\cal Z_L}{\rla}}
\newcommand{\rzt}{\overset{\cal Z_R}{\rla}}
$$

[TOC]

### 1.1  复习与思考题

#### 1.1.3  三种误差

- 算法无关
  - 模型误差：数学模型与实际问题之间的误差.
  - 观测误差：物理量与观测值之间的误差.
- 算法相关
  - 截断误差（方法误差）：近似解与精确解之间的误差.
  - 舍入误差：四舍五入、进制转换的误差.



#### 1.1.4  绝对误差、相对误差、有效数字

- 误差衡量

  - 有量纲
    - 绝对误差：$ e^* = x^* - x $.
    - 绝对误差限：$ \ve^* $ 是 $ e^* $ 的上界.

  - 备注
    - 不等式简写：$ x = x^* \pm \ve^* $.
    - 一般写为：$ \ve^* = 0.5 \cp 10^{-n} $.

  - 无量纲
    - 相对误差：$ e_\rm r^* = \dfrac{e^*}{x} $ 或 $ \dfrac{e^*}{x^*} $.
    - 相对误差限：$ \ve_\rm r^* = \dfrac{\ve^*}{\vqty{x^*}} $.

- 有效数字

  - 对于 $ x^* = \pm 10^m \cp (a_1 + a_2 \cp 10\inv + \cdots + a_l \cp 10^{-{l-1}}) $，
  - 若具有 $n$ 位有效数字，则其相对误差限 $ \ve_\rm r^* \le \dfrac{1}{2a_1} \cp 10^{-{n-1}} $.
  - 若相对误差限 $ \ve_\rm r^* \le \dfrac{1}{2 (a_1 + 1)} \cp 10^{-(n-1)} $，则至少具有 $n$ 位有效数字.



#### 1.1.5  算法的稳定性

即计算过程中舍入误差不增长.

> 稳定性是计算方法引起的，而非数值问题自身固有.



#### 1.1.6  问题的病态性

即输入数据的微小扰动引起输出数据相对误差很大的问题.

> 病态性是数值问题自身固有的，而非计算方法引起.



#### 1.1.7  迭代法

- 求解 $ \sqrt a $.

  - $ x_{n+1} = \dfrac{1}{2} \pqty{x_n + \dfrac{a}{x_n}} $.

  - 一般 4~5 次迭代就能达到 $ 10^{-8} $ 的精度.

- 求解 $ \sqrt[k]a $.

  - $ x_{n+1} = \dfrac{1}{k} \pqty{
    	(k - 1) x_n + \dfrac{a}{x_n^{k-1}}
    } $，或者说

    $ x_{n+1} = x_n \pqty{1 - \dfrac{1}{k} + \dfrac{a}{k x_n^k}} $.

  - 上二式本质上是牛顿迭代法.



#### 1.1.8  以直代曲

同 [1.1.7  迭代法](# 1.1.7  迭代法).



#### 1.1.9  松弛法

松弛法：$ \overline a = a_n + \omega (a_n - a_{n-1}) $. 以复化求积公式为例，

- $ T_1 = \dfrac{x_1 - x_0}{2} \bqty{f(x_0) + f(x_1)} $.
- $ T_2 = \dfrac{x_2 - x_0}{4} \bqty{f(x_0) + 2f(x_1) + f(x_2)} $.
- $ S_1 = T_2 + \dfrac{T_2 - T_1}{3} = \dfrac{x_2 - x_0}{6} \bqty{f(x_0) + 4f(x_1) + f(x_2)} $.



#### 1.10  无穷级数的和

一般来说，“大数吃小数”，最后稳定为常数.（除非软件可以自动调整精度）



#### 1.11  一些命题

1. √.
2. ×，病态性是问题固有的.
3. ×，只有良态问题才能通过稳定的算法得到较好的近似值.
4. ×，<span style="color: red">还与初值有关</span>.
5. ×，还与初值有关.
6. ×，可以通过其他方式避免有效数字的损失.
7. ×，可能存在大数吃小数的问题.



### 1.2  习题

#### 1.2.1  函数的绝对误差

- 法一（由定义）$ \ve(\ln x) = \ln x^* - \ln x = \ln\pqty{1 + \dfrac{x^* - x}{x}} \approx \dfrac{x^* - x}{x} = \delta $.
- 法二（由公式）$ \ve(\ln x) \approx \ddv{\ln x^*}{x^*} \ve(x) = \dfrac{\ve(x)}{x^*} = \dfrac{x^* \delta}{x^*} = \delta $.

**备注**	法二是法一的一般情况.

---

#### 1.2.2  函数的相对误差

- 法一（由公式）$ \ve_\rm r(x^n) = \dfrac{\ve(x^n)}{x^n} = \dfrac{n x^{n-1} \ve(x)}{x^n} = n \delta $.
- 法二（条件数）$ C_p = \vqty{\dfrac{x f'(x)}{f(x)}} = n $，$ \ve_\rm r(x^n) = n\delta $.

**备注**	法二是法一的一般情况.

---

#### 1.2.3  数字的有效位数

1. 5 位.
2. 2 位.
3. 4 位.
4. 5 位.
5. 2 位.

---

#### 1.2.4  多元函数误差限

1. 单变量的误差限
   1. $ \ve(x_1^*) = \dfrac{1}{2} \cp 10^{-4} $.
   2. $ \ve(x_2^*) = \dfrac{1}{2} \cp 10^{-3} $.
   3. $ \ve(x_3^*) = \dfrac{1}{2} \cp 10^{-1} $.
   4. $ \ve(x_4^*) = \dfrac{1}{2} \cp 10^{-3} $.
2. 表达式的误差限
   1. $ \ve(y_1) = 1.05 \cp 10^{-4} \approx \dfrac{1}{2} \cp 10^{-3} $.
   2. $ \ve(y_2) \approx \vqty{x_1^* x_2^* x_3^*} \pqty{\dfrac{\ve(x_1^*)}{x_1^*} + \dfrac{\ve(x_2^*)}{x_2^*} + \dfrac{\ve(x_3^*)}{x_3^*}} \approx 0.21479 \approx \dfrac{1}{2} \cp 10^{-1} $.
   3. $ \ve(y_3) \approx \dfrac{\vqty{x_2^*} \ve(x_4^*) + \vqty{x_4^*} \ve(x_2^*)}{\vqty{x_4^*}^2} \approx 0.8865 \cp 10^{-5} \approx \dfrac{1}{2} \cp 10^{-4} $.

---

#### 1.2.5  函数相对误差限

$ V = \dfrac{4}{3} \pi R^3 $，$ C_p = \vqty{\dfrac{R \cdot 4 \pi R^2}{\cfrac{4}{3} \pi R^3}} = 3 $.

$ \ver(R^*) = \dfrac{1}{C_p} = 0.33\% $.

---

#### 1.2.6  递推公式的误差

$ Y_n = Y_0 - \dfrac{n}{100} \sqrt{783} $，

$ Y_{100}^* = Y_0 - \sqrt{783} = 0.018 $，

$ \ve(Y_{100}^*) = \dfrac{1}{2} \cp 10^{-3} $.

---

#### 1.2.7  按有效数字求解

$ x_{1, 2} = 28 \pm \sqrt{783} $，

$ x_1^* = 28 + \sqrt{783} \approx 55.982 $，舍入误差 $ \ve(x_1^*) = \dfrac{1}{2} \cp 10^{-3} $，故具有 5 位有效数字.

$ x_2^* = \dfrac{1}{28 + \sqrt{783}} \approx 0.017863 $，舍入误差 $ \ve(x_2^*) = 0.160 \cp 10^{-6} $，故具有 5 位有效数字.

**备注**	 

- 实际上 $ x_1^* $ 的表达式中应将根号替换为小数，不过那样麻烦也不直观.
- 注意该题首先需要从理论上证明舍入误差可以足够小，否则后续计算是没有意义的.

---

#### 1.2.8  舍入误差的减少

对于 $ f(x) = \ln x $，$ C_p = \vqty{\dfrac{x f'(x)}{f(x)}} = \vqty{\dfrac{1}{\ln x}} $，

故 $ x \approx y $ 时 $ C_0 $ 充分大，是病态问题，这样做不能减少相对误差，但是可以减少绝对误差.

---

#### 1.2.9  函数误差的控制

$ S = a^2 $，$ \ve(S^*) = 2a^* \ve(a^*) $，

$ \ve(a^*) \le \dfrac{\ve(S^*)}{2a^*} \approx \dfrac{1}{2} \cp 10^{-2} $.

---

#### 1.2.10  误差的变化趋势

$ \ve(S^*) = gt^* \ve(t^*) $，故 $t$ 增加时 $S$ 的绝对误差增加.

$ C_p = 2 $，$ \ver(S^*) = 2 \ver(t^*) = \dfrac{2 \ve(t)}{t} $，故 $t$ 增加时 $S$ 的相对误差减小.

---

#### 1.2.11  算法数值稳定性

$ \ve(y_n^*) = 10 \ve(y_{n-1}^*) $，故 $ \ve(y_{10}^*) = 10^{10} \cp \dfrac{1}{2} \cp 10^{-2} = \dfrac{1}{2} \cp 10^8 $，

舍入误差逐渐增大，故计算过程不稳定.

---

#### 1.2.12  计算方法的优劣

1. $ \ve(f_1^*) = 0.013 \ve(x^*) $.
2. $ \ve(f_2^*) = 0.24 \ve(x^*) $.
3. $ \ve(f_3^*) = 0.0053 \ve(x^*) $.
4. $ \ve(f_4^*) = 70 \ve(x^*) $.

故第三种方法好.

---

#### 1.2.13  绝对误差的减小

0. 有效位数为 6 位函数表中，$ \sqrt{30^2 - 1} \approx 29.9833 $.
1. $ \ve(f_1^*) = \dfrac{\cfrac{1}{2} \cp 10^{-4}}{30 - \sqrt{899}} = 0.00299 \pqty{\approx \dfrac{1}{2} \cp 10^{-2}} $.
2. $ \ve(f_2^*) = 0.834 \cp 10^{-6} $.

故第二种方法误差较小.

**备注**	虽然习惯上将误差限表示为 $ \dfrac{1}{2} \cp 10^{-n} $，但是这样不利于理论推导，而仅仅在实践应用上方便.

---

#### 1.2.14  秦九韶算法求值

$ p(x) = ((3x^2 - 2) x^2 + 1) x + 7 $，$ p(3) = 685 $.

代码略.

---

#### 1.2.15  迭代法求方程根

```mathematica
f[x_] := Which[
    x == 0,	1,
    x > 0,	1/(1 + f[x - 1])
];
N[f[5]]
Abs[% - (Sqrt[5] - 1)/2]
```

由计算机得 $ x_5 = \dfrac{8}{13} = 0.615385 $，误差为 $ 0.00265 $，故有两位有效数字.

---

#### 1.2.16  复化求积松弛法

1. $ f^* = \e^{\tfrac{1}{2}} - 1 \approx 0.648721 $.

2. $ f^* = \dfrac{\e^0 + 2 \e^{1/4} + \e^{1/2}}{8} \approx 0.652096 $.

3. $ T_1 = \dfrac{\e^0 + \e^{1/2}}{4} = 0.662180 $,

   $ T_2 = 0.652096 $.

   $ S_1 = \dfrac{4}{3} T_2 - \dfrac{1}{3} T_1 = 0.648735 $.

---

#### 1.2.17  迭代公式的改善

```mathematica
g[x_] := Which[
	x == 0, 1,
	x > 0, 7/25 g[x - 1] + 18/(25 (1 + g[x - 1]))
];
N[g[3]]
Abs[% - (Sqrt[5] - 1)/2]
```

由计算机得 $ x_3 = 0.618035 $，误差为 $ 9.55 \cp 10^{-7} $，故有 5 位有效数字，已经比 15 题计算 5 次的精度高许多了.