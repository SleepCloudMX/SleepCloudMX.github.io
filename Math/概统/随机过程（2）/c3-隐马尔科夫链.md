<h1 align="center">隐马尔科夫链</h1>

$$
% 设置
\newcommand{\aneg}[1]{\hspace{-0.75em}&#1&\hspace{-0.75em}}
\newcommand{\aneq}{\aneg{=}}
% 上述指令用于在使用 array 环境时调整等号左右间距
\newcommand{\noeq}{&\hspace{1.3em}}
% 上述指令用于 align 环境中, 类似与 &= 但不显示等号.
\renewcommand{\d}{\displaystyle}

% 字符
\renewcommand{\i}{\mathrm{i}}
\renewcommand{\j}{\mathrm{j}}
\renewcommand{\k}{\mathrm{k}}
\newcommand{\e}{\textup{e}}
\newcommand{\ve}{\varepsilon}
\newcommand{\Beta}{\mathrm{B}}
\newcommand{\omicron}{\mathit{o}}
\newcommand{\Omicron}{\mathit{O}}

% 原本的定义为:
% \newcommand{\cal}[1]{\mathcal{#1}}
\newcommand{\bm}[1]{\boldsymbol{#1}}
\renewcommand{\cal}[1]{\mathcal#1}
\renewcommand{\scr}[1]{\mathscr#1}
\renewcommand{\frak}[1]{\mathfrak#1}
\newcommand{\bb}[1]{\mathbb#1}

% 数集
\newcommand{\D}{\mathbb{D}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\J}{\mathbb{J}}
\newcommand{\K}{\mathbb{K}}
\renewcommand{\L}{\mathbb{L}}

% 上下标
\newcommand{\trans}{^\mathrm{T}}
\newcommand{\inv}{^{-1}}
\newcommand{\madj}[1]{^{\pqty{#1^*}}}	% m 重伴随矩阵
\newcommand{\adj}{^*}
\newcommand{\vector}[1]{\overrightarrow{#1}}
\newcommand{\wavy}[1]{\overset\sim#1}	% \tilde 或 \widetilde 不明显, 容易与 \bar 或 \overline 混淆

% 序列
\newcommand{\ccdots}{\cdot\cdots\cdot}
\newcommand{\oneton}{1,2,\cdots,n}
\newcommand{\oneto}[1]{1,2,\cdots,#1}

\newcommand{\ssto}[3]{#1_1 #3 #1_2 #3 \cdots #3 #1_{#2}}
\newcommand{\ssup}[3]{#1^1 #3 #1^2 #3 \cdots #3 #1^{#2}}
\newcommand{\soneto}[2]{\ssto{#1}{#2}{,}}
\newcommand{\splus}[2]{\ssto{#1}{#2}{+}}

% 括号
\newcommand{\aqty}[1]{\expval{#1}}
\newcommand{\pbqty}[1]{\left(#1\right]}
\newcommand{\bpqty}[1]{\left[#1\right)}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}

% 矩阵宏简写
\newcommand{\bmatrix}[1]{\begin{bmatrix}#1\end{bmatrix}}
\newcommand{\Bmatrix}[1]{\begin{Bmatrix}#1\end{Bmatrix}}
\newcommand{\vmatrix}[1]{\begin{vmatrix}#1\end{vmatrix}}
\newcommand{\Vmatrix}[1]{\begin{Vmatrix}#1\end{Vmatrix}}

% 常用微分
\newcommand{\dx}{\dd{x}}
\newcommand{\dy}{\dd{y}}
\newcommand{\dz}{\dd{z}}
\newcommand{\dt}{\dd{t}}
\newcommand{\ds}{\dd{s}}
\newcommand{\dr}{\dd{r}}

% 一般的微分
% 如果只使用 \dd{x}\dd{y} 的话, 中间会有多余的间隔.
\newcommand{\df}{\dd}
\newcommand{\ddf}[2]{\,\mathrm{d}#1\mathrm{d}#2}	% 微分形式 differential form
\newcommand{\dddf}[3]{\,\mathrm{d}#1\mathrm{d}#2\mathrm{d}#3}

% 高阶微分
\newcommand{\dxdy}{\ddf{x}{y}}
\newcommand{\dydz}{\ddf{y}{z}}
\newcommand{\dzdx}{\ddf{z}{x}}
\newcommand{\dudv}{\ddf{u}{v}}
\newcommand{\drdt}{\ddf{r}{\theta}}
\newcommand{\dxdydz}{\dddf{x}{y}{z}}

% 矩阵的宏指令
\newcommand{\pmcmn}[3]{\begin{pmatrix}
	#1_{11} & #1_{12} & \cdots & #1_{1#3} \\
	#1_{21} & #1_{22} & \cdots & #1_{n#3} \\
	\vdots & \vdots && \vdots \\
	#1_{#2 1} & #1_{#2 2} & \cdots & #2_{n#3} \\
\end{pmatrix}}

\newcommand{\pmc}[1]{\pmcmn{#1}{n}{n}}
\newcommand{\pvcn}[2]{\begin{pmatrix}
	#1_1 \\ #1_2 \\ \vdots \\ #1_{#2}
\end{pmatrix}}

\newcommand{\pvc}[1]{\pvcn{#1}{n}}
\newcommand{\pto}{\overset{P}{\to}}

% 函数名
\renewcommand{\char}{\operatorname{char}}	% 由于已存在此命令, 不可使用 DeclareMathOperator
\renewcommand{\r}{\operatorname{r}}
\DeclareMathOperator{\st}{s.t.\,}	% 虽然不是函数名, 但用了这个指令就放这儿了.
\DeclareMathOperator{\diag}{diag}	% 不需要定义太多, 一个文件里用到什么定义什么,
\DeclareMathOperator{\Ker}{Ker}		% 毕竟特殊的函数名太多太多了.
\DeclareMathOperator{\Aut}{Aut}		% 便捷与效率的权衡.
\DeclareMathOperator{\Inn}{Inn}
\DeclareMathOperator{\GL}{GL}
\DeclareMathOperator{\SL}{SL}
\DeclareMathOperator{\stab}{stab}
\DeclareMathOperator{\orb}{orb}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\Corr}{Corr}
\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Outer}{Outer}
\DeclareMathOperator{\Even}{Even}
\DeclareMathOperator{\Scalar}{Scalar}
\DeclareMathOperator{\Vector}{Vector}
\DeclareMathOperator{\arsh}{arsh}
\DeclareMathOperator{\arch}{arch}
\DeclareMathOperator{\arth}{arth}
\renewcommand{\Re}{\operatorname{Re}}	% 自带 \Re 的效果是 \mathrm{Re}, 前后无空格, 故重写
\renewcommand{\Im}{\operatorname{Im}}
\DeclareMathOperator{\Sa}{Sa}
\DeclareMathOperator{\Si}{Si}

% 运算符
% 可以用 \bigcap, \bigcup, \bigoplus, \bigotimes 替代
\newcommand{\capop}{\displaystyle\mathop\cap\limits}
\newcommand{\cupop}{\displaystyle\mathop\cup\limits}
\newcommand{\oplusop}{\mathop\oplus\limits}
\newcommand{\otimesop}{\mathop\otimes\limits}
\newcommand{\bigoplusop}{\mathop\bigoplus\limits}
\newcommand{\bigotimesop}{\mathop\bigotimes\limits}

% 积分
\newcommand{\dint}{\displaystyle\int}
\newcommand{\inti}{\dint_{-\infty}^{+\infty}}
\newcommand{\intoi}{\dint_0^{+\infty}}

\newcommand{\intl}{\displaystyle\int\limits}
\newcommand{\iintl}{\displaystyle\iint\limits}
\newcommand{\iiintl}{\displaystyle\iiint\limits}

% 求和
\newcommand{\dsum}{\displaystyle\sum}
\newcommand{\csum}[1]{\dsum_{#1=1}^\infty}
\newcommand{\nsum}{\csum{n}}
\newcommand{\nsuminf}{\dsum_{n=-\infty}^{+\infty}}
\newcommand{\ksum}{\csum{k}}
\newcommand{\nosum}{\dsum_{n=0}^\infty}
\newcommand{\insum}{\dsum_{i=1}^n}
\newcommand{\knsum}{\dsum_{k=1}^n}

% 求积
\newcommand{\dprod}{\displaystyle\prod}
\newcommand{\nprod}{\dprod_{n=1}^\infty}
\newcommand{\noprod}{\dprod_{n=0}^\infty}
\newcommand{\inprod}{\dprod_{i=1}^n}

% 极限
\newcommand{\liml}{\lim\limits}
\newcommand{\ulim}{\overline\lim\limits_{n\to\infty}}
\newcommand{\dlim}{\underline\lim\limits_{n\to\infty}}
% 注意这里的 d 是 down, 而不是 displaystyle

\newcommand{\xlim}{\lim\limits_{x\to x_0}}
\newcommand{\nlim}{\lim\limits_{n\to\infty}}
\newcommand{\clim}[1]{\lim\limits_{#1\to\infty}}

% 并集
\newcommand{\incup}{\bigcup_{i=1}^n}
\newcommand{\ncup}{\bigcup_{n=1}^\infty}
\newcommand{\icup}{\bigcup_{i=1}^\infty}

% 交集
\newcommand{\incap}{\bigcap_{i=1}^n}
\newcommand{\ncap}{\bigcap_{n=1}^\infty}
\newcommand{\icap}{\bigcap_{i=1}^\infty}

% 差分
\newcommand{\DD}{\Delta}
\newcommand{\DV}[2]{\dfrac{\DD#1}{\DD#2}}
\newcommand{\nDV}[3]{\dfrac{\DD^{#1}#2}{\DD#3^{#1}}}

% 求导
\newcommand{\ddv}{\displaystyle\dv}
\newcommand{\dpdv}{\displaystyle\pdv}

% 最值 (返回参数); 暂时先这么凑合着用吧
\newcommand{\argmax}[1]{\underset{#1}{\operatorname{argmax}}}
\newcommand{\argmin}[1]{\underset{#1}{\operatorname{argmin}}}

% 缩写
\newcommand{\LRA}{\Leftrightarrow}
\newcommand{\RLA}{\Leftrightarrow}
\newcommand{\LA}{\Leftarrow}
\newcommand{\RA}{\Rightarrow}

\newcommand{\lra}{\leftrightarrow}
\newcommand{\rla}{\leftrightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\ra}{\rightarrow}

\newcommand{\QRLA}{\quad\RLA\quad}
\newcommand{\QRA}{\quad\RA\quad}
\newcommand{\LLRA}{\Longleftrightarrow}

\newcommand{\QNRA}{\quad\nRightarrow\quad}
\newcommand{\qnra}{\quad\nrightarrow\quad}

\newcommand{\wt}{\widetilde}

% 图形符号
\newcommand{\qed}{\quad\square}
\renewcommand{\parallel}{\mathrel{/\mskip-2.5mu/}}
\newcommand{\paralleleq}{\hspace{0.5em}{^{^{\parallel}}}\hspace{-1.04em}=}
\newcommand{\rt}{\matrm{Rt}\triangle}

% 分块矩阵
\newenvironment{mat}[1]{
	\begin{array}{#1}
}{
	\end{array}
}

\newenvironment{pmat}[1]{
	\left( \begin{array}{#1}
}{
	\end{array} \right)
}

\newenvironment{bmat}[1]{
	\left[ \begin{array}{#1}
}{
	\end{array} \right]
}

\newenvironment{Bmat}[1]{
	\left\{ \begin{array}{#1}
}{
	\end{array} \right\}
}

\newenvironment{vmat}[1]{
	\left\lvert \begin{array}{#1}
}{
	\end{array} \right\rvert
}

\newenvironment{Vmat}[1]{
	\left\lVert \begin{array}{#1}
}{
	\end{array} \right\rVert
}
$$

[TOC]

### 3.1  隐马尔科夫链的概念

**定义**	如果随机过程 $ \Bqty{(X_n, S_n), n > 0} $ 满足以下条件, 则称为 **隐马尔科夫链**,

1. 状态序列 $ \Bqty{X_n, n > 0} $ 是马尔科夫链并且不可观测, 状态空间为 $ \cal S $.
2. 信号序列 $ \Bqty{S_n, n > 0} $ (非马尔科夫链) 是可观测的, 信号空间为 $ \scr S $.
3. 进入状态 $ j $ 时以概率 $ p(s \mid j) $ 发出信号 $ s $, 其中 $ \forall j \in \cal S \colon \dsum_{s \in \scr S} p(s \mid j) = 1 $.
4. 给定状态 $j$ 时, $ p(s \mid j) $ 独立于先前的状态与信号.

**问题 0**	已知信号序列, 计算状态的概率.
$$
% \begin{align}
% F_1(i) &= p_i p(s_1 \mid i)
% \\
% F_n(j) &\equiv P\Bqty{
% 	\bm S^n = \bm s_n, X_n = j
% } \\
% &= P\Bqty{
% 	\bm S^{n-1} = \bm s_{n-1}, S_n = s_n, X_n = j
% } \\
% &= \sum_i P\Bqty{
% 	\bm S^{n-1} = \bm s_{n-1}, X_{n-1} = i, X_n = j, S_n = s_n
% } \\
% &= \sum_i F_{n-1}(i) P\Bqty{
% 	X_n = j, S_n = s_n \mid
% 	\bm S^{n-1} = \bm s_{n-1}, X_{n-1} = i
% } \\
% &= \sum_i F_{n-1}(i) P\Bqty{
% 	X_n = j, S_n = s_n \mid X_{n-1} = i
% } \\
% &= \sum_i F_{n-1}(i) P_{ij} p(s_n \mid j)
% \\
% &= p(s_n \mid j) \sum_i F_{n-1}(i) P_{ij},
% \end{align}
\begin{align}
F_n(j) &:= P\Bqty{
    \bm S^n = \bm s_n, X_n = j
} \\
&= \begin{cases}
    p_j p(s_1 \mid j), & n = 1, \\
    p(s_n \mid j) \sum_i  F_{n-1}(i) P_{ij}, & n > 1.
\end{cases}
\end{align}
$$



### 3.2  问题 1：计算产生信号序列的概率

**问题 1**	计算产生信号序列的概率.

**思路 1.1**	遍历算法
$$
P\Bqty{\bm S^n = \bm s_n} = \dsum_{i_1, \cdots, i_n} p(s_1 \mid i_1) \cdots p(s_n \mid i_n) p_{i_1} P_{i_1 i_2} \cdots P_{i_{n-1} i_n}.
$$
**备注**	计算量大, 约 $ 2n N^n $ 次.

**思路 1.2**	向前递推
$$
P\Bqty{\bm S^n = \bm s_n} = \dsum_i F_n(i).
$$
**备注**	计算量较小, 约 $ nN $ 次.

**思路 1.3**	向后递推（略）
$$
\begin{align}
B_k(i) &:= P\Bqty{
	S_{k+1} = s_{k+1}, \cdots, S_n = s_n \mid X_k = i
}
% \\
% &= \sum_{j} P\Bqty{
% 	S_{k+1} = s_{k+1}, \cdots, S_n = s_n
% 	\mid X_k = i, X_{k+1} = j
% } P_{ij}
% \\
% &= \sum_j  p(s_{k+1} \mid j) P\Bqty{
% 	S_{k+2} = s_{k+2}, \cdots, S_n = n \mid X_{k+1} = j
% } P_{ij}
\\
&= \begin{cases}
	\sum_j P_{ij} p(s_n \mid j), & k = n-1, \\
	\sum_j P_{ij} \cdot p(s_{k+1} \mid j) \cdot B_{k+1}(j), & k < n-1.
\end{cases}
\end{align}
$$
于是有 $ \d P\Bqty{
	\bm S^n = \bm s_n
} = \sum_i p_i p(s_1 \mid i) B_1(i) $.

**思路 1.4**	前后递推; Forward-Backward 算法（略）
$$
P\Bqty{
	\bm S^n = \bm s_n
} = \dsum_j F_k(j) B_k(j)
$$



### 3.3  问题 2：由信号序列预测状态序列

**问题 2**	已知信号序列, 预测前 $n$ 个状态.

**思路 2.1**	预测单个状态, 使得到该状态的概率最大.（略）
$$
P\Bqty{
	X_k = j \mid \bm S^n = \bm s_n
} = \dfrac{
	P\Bqty{\bm S^n = \bm s_n, X_k = j}
}{
	P\Bqty{\bm S^n = \bm s_n}
} = \dfrac{
	F_k(j) B_k(j)
}{
	\sum_j F_k(j) B_k(j)
}.
$$
于是 $ \hat j = \argmax j F_k(j) B_k(j) $.

**备注**	这样可以使预测对的状态数的期望最大, 但是得到的未必是最可能状态序列.

**思路 2.2**	预测状态序列, 使得到整个轨迹的概率最大.

**思路 2.2.1**	遍历算法
$$
P\Bqty{
	\bm X_n = (i_1, \cdots, i_n)
	\mid \bm S^n = \bm s_n
} = \dfrac{
	P\Bqty{
		\bm X_n = (i_1, \cdots, i_N),
		\bm S^n = \bm s_n
	}
}{
	P\Bqty{\bm S^n = \bm s_n}
}
$$
于是 $ (i_1, \cdots, i_n) = \argmax{i_1, \cdots, i_n} P\Bqty{\bm X_n = (i_1, \cdots, i_n) \mid \bm S^n = \bm s_n} $.

**备注**	这样可以得到最可能状态序列, 但是计算量大.

**思路 2.2.2**	Viterbi 算法
$$
\begin{align}
V_k(j) &:= \max_{i_1, \cdots i_{k-1}} P\Bqty{
	\bm X_{k-1} = (i_1, \cdots, i_{k-1}),
	X_k = j, \bm S^k = \bm s_k
} \\
&= \begin{cases}
	p_j p(s_1 \mid j), & k = 1, \\
	p(s_k \mid j) \max_i P_{ij} V_{k-1}(i), & 1 < k \le n.
\end{cases}
\end{align}
$$
欲求最可能的状态序列, 先对每个 $j$ 确定 $ V_1(j) $, 再依次确定 $ V_n(j) $.

之后令 $ i_n = \argmax i V_n(i) $, 再依次令 $ i_k = \argmax i P_{i,i_{k+1}} V_{k}(i) $.

